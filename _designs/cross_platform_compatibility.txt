CROSS-PLATFORM COMPATIBILITY DESIGN
====================================
Status: Proposed Enhancement
Priority: Medium
Affected Platforms: macOS, Linux

================================================================================
OVERVIEW
================================================================================

This document addresses two cross-platform compatibility issues identified
during code review:

1. EXIFTOOL INSTALLATION
   - Auto-download only works on Windows
   - macOS/Linux users must manually install ExifTool
   - No guidance or detection provided for non-Windows users

2. UNICODE FILENAME NORMALIZATION
   - macOS uses NFD (decomposed) normalization for filenames
   - Windows/Linux use NFC (composed) normalization
   - Can cause matching failures for files with non-ASCII characters

Both issues can cause the tool to behave differently or fail silently on
macOS/Linux compared to Windows.

================================================================================
ISSUE 1: EXIFTOOL INSTALLATION
================================================================================

CURRENT BEHAVIOR
----------------

Location: pef/core/exiftool.py

```python
def get_exiftool_path(base_dir: Optional[str] = None) -> Optional[str]:
    # 1. Check system PATH
    if shutil.which("exiftool"):
        return "exiftool"

    # 2. Check local tools folder
    local_path = os.path.join(base_dir, EXIFTOOL_DIR, EXIFTOOL_EXE)
    if os.path.exists(local_path):
        return local_path

    # 3. Attempt auto-download (Windows only)
    if sys.platform == "win32":
        if auto_download_exiftool(base_dir):
            return local_path

    # Not found - only logs a warning
    logger.warning("ExifTool not found. Install from https://exiftool.org/")
    return None
```

PROBLEMS
--------

1. Silent degradation: When ExifTool isn't found on macOS/Linux, the tool
   continues but skips all EXIF metadata (GPS, people tags). Users may not
   notice this until they check their processed files.

2. No installation guidance: The warning message doesn't provide platform-
   specific installation instructions.

3. No pre-flight check: The dry-run mode shows "ExifTool: Not available" but
   doesn't explain how to install it or what features will be missing.

4. Inconsistent experience: Windows users get a seamless experience while
   macOS/Linux users must research and install ExifTool manually.

PROPOSED SOLUTION
-----------------

A. Enhanced Detection and User Feedback
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Add platform-specific installation instructions and clearer warnings:

```python
# pef/core/exiftool.py

INSTALL_INSTRUCTIONS = {
    "darwin": [
        "ExifTool is required for GPS and people metadata.",
        "Install via Homebrew:",
        "    brew install exiftool",
        "",
        "Or download from: https://exiftool.org/",
    ],
    "linux": [
        "ExifTool is required for GPS and people metadata.",
        "Install via package manager:",
        "    Ubuntu/Debian: sudo apt install libimage-exiftool-perl",
        "    Fedora/RHEL:   sudo dnf install perl-Image-ExifTool",
        "    Arch Linux:    sudo pacman -S perl-image-exiftool",
        "",
        "Or download from: https://exiftool.org/",
    ],
    "win32": [
        "ExifTool is required for GPS and people metadata.",
        "It will be downloaded automatically on first run.",
        "",
        "Or download manually from: https://exiftool.org/",
    ],
}


def get_install_instructions() -> List[str]:
    """Get platform-specific ExifTool installation instructions."""
    platform = sys.platform
    if platform.startswith("linux"):
        platform = "linux"
    return INSTALL_INSTRUCTIONS.get(platform, INSTALL_INSTRUCTIONS["linux"])


def print_install_instructions() -> None:
    """Print platform-specific installation instructions."""
    for line in get_install_instructions():
        if line:
            logger.info(line)
        else:
            logger.info("")
```

B. Auto-Download for macOS (Homebrew Detection)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For macOS users with Homebrew installed, offer to install automatically:

```python
# pef/core/exiftool.py

def auto_install_exiftool_macos() -> bool:
    """Attempt to install ExifTool via Homebrew on macOS.

    Returns:
        True if installation succeeded, False otherwise.
    """
    if sys.platform != "darwin":
        return False

    # Check if Homebrew is available
    if not shutil.which("brew"):
        logger.info("Homebrew not found. Please install ExifTool manually.")
        return False

    try:
        import subprocess
        logger.info("Installing ExifTool via Homebrew...")
        result = subprocess.run(
            ["brew", "install", "exiftool"],
            capture_output=True,
            text=True,
            timeout=300  # 5 minute timeout
        )

        if result.returncode == 0:
            logger.info("ExifTool installed successfully!")
            return True
        else:
            logger.warning(f"Homebrew installation failed: {result.stderr}")
            return False

    except subprocess.TimeoutExpired:
        logger.warning("ExifTool installation timed out")
        return False
    except Exception as e:
        logger.warning(f"Failed to install via Homebrew: {e}")
        return False
```

C. Auto-Download for Linux (AppImage or Static Binary)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ExifTool provides a platform-independent Perl distribution. We can download
and use it directly:

```python
# pef/core/exiftool.py

EXIFTOOL_UNIX_URL = "https://exiftool.org/Image-ExifTool-{version}.tar.gz"

def auto_download_exiftool_unix(base_dir: str) -> bool:
    """Download ExifTool for Unix-like systems (macOS/Linux).

    Downloads the platform-independent Perl distribution.
    Requires Perl to be installed (standard on macOS/most Linux).

    Args:
        base_dir: Base directory to install into.

    Returns:
        True if download succeeded, False otherwise.
    """
    import tarfile
    import urllib.request
    import urllib.error

    # Check Perl is available
    if not shutil.which("perl"):
        logger.warning("Perl not found. Cannot use downloaded ExifTool.")
        return False

    tools_dir = os.path.join(base_dir, EXIFTOOL_DIR)
    os.makedirs(tools_dir, exist_ok=True)

    try:
        # Get latest version
        logger.info("Checking for latest ExifTool version...")
        with urllib.request.urlopen("https://exiftool.org/ver.txt") as response:
            version = response.read().decode().strip()

        # Download tarball
        url = EXIFTOOL_UNIX_URL.format(version=version)
        tar_path = os.path.join(tools_dir, "exiftool.tar.gz")

        logger.info(f"Downloading ExifTool {version}...")
        urllib.request.urlretrieve(url, tar_path)

        # Extract
        logger.info("Extracting...")
        with tarfile.open(tar_path, "r:gz") as tar:
            tar.extractall(tools_dir)

        # Find extracted directory and create wrapper script
        for item in os.listdir(tools_dir):
            item_path = os.path.join(tools_dir, item)
            if os.path.isdir(item_path) and item.startswith("Image-ExifTool"):
                # Create executable wrapper script
                exiftool_script = os.path.join(item_path, "exiftool")
                wrapper_path = os.path.join(tools_dir, "exiftool")

                # Create symlink or copy
                if os.path.exists(exiftool_script):
                    if os.path.exists(wrapper_path):
                        os.remove(wrapper_path)
                    os.symlink(exiftool_script, wrapper_path)
                    os.chmod(wrapper_path, 0o755)
                    break

        os.remove(tar_path)
        logger.info("ExifTool installed successfully!")
        return True

    except urllib.error.URLError as e:
        logger.warning(f"Network error downloading ExifTool: {e}")
        return False
    except tarfile.TarError as e:
        logger.warning(f"Failed to extract ExifTool: {e}")
        return False
    except OSError as e:
        logger.warning(f"File system error during ExifTool install: {e}")
        return False
    except Exception as e:
        logger.warning(f"Auto-download failed: {e}")
        return False
```

D. Updated get_exiftool_path() Function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```python
def get_exiftool_path(base_dir: Optional[str] = None, auto_install: bool = True) -> Optional[str]:
    """Find ExifTool executable.

    Checks in order:
    1. System PATH
    2. Local tools directory
    3. Attempts auto-download/install (if auto_install=True)

    Args:
        base_dir: Base directory for local tools folder.
        auto_install: Whether to attempt automatic installation.

    Returns:
        Path to exiftool executable, or None if not found.
    """
    # 1. Check system PATH
    if shutil.which("exiftool"):
        return "exiftool"

    # 2. Check local tools folder
    if base_dir is None:
        base_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))

    local_path = os.path.join(base_dir, EXIFTOOL_DIR, EXIFTOOL_EXE)
    if os.path.exists(local_path):
        return local_path

    # 3. Attempt auto-download/install
    if auto_install:
        success = False

        if sys.platform == "win32":
            success = auto_download_exiftool(base_dir)
        elif sys.platform == "darwin":
            # Try Homebrew first, fall back to direct download
            success = auto_install_exiftool_macos()
            if not success:
                success = auto_download_exiftool_unix(base_dir)
        else:  # Linux and other Unix
            success = auto_download_exiftool_unix(base_dir)

        if success:
            # Re-check paths after installation
            if shutil.which("exiftool"):
                return "exiftool"
            if os.path.exists(local_path):
                return local_path

    # Not found - print helpful instructions
    print_install_instructions()
    return None
```

E. CLI Enhancement: Pre-flight Check
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Add a --check flag that validates the environment before processing:

```python
# pef/cli/main.py

def check_environment() -> bool:
    """Check that all required tools are available.

    Returns:
        True if environment is ready, False otherwise.
    """
    print("Checking environment...")

    all_ok = True

    # Check ExifTool
    exiftool_path = get_exiftool_path(auto_install=False)
    if exiftool_path:
        print(f"  ExifTool: OK ({exiftool_path})")
    else:
        print("  ExifTool: NOT FOUND")
        for line in get_install_instructions():
            print(f"    {line}")
        all_ok = False

    # Check Python dependencies
    try:
        import filedate
        print("  filedate: OK")
    except ImportError:
        print("  filedate: NOT FOUND (pip install filedate)")
        all_ok = False

    try:
        import exiftool
        print("  pyexiftool: OK")
    except ImportError:
        print("  pyexiftool: NOT FOUND (pip install pyexiftool)")
        all_ok = False

    return all_ok
```

Usage:
```
python -m pef --check
python -m pef --path /photos --check  # Check before processing
```

================================================================================
ISSUE 2: UNICODE FILENAME NORMALIZATION
================================================================================

CURRENT BEHAVIOR
----------------

Location: pef/core/matcher.py, pef/core/scanner.py

The current code does not handle Unicode normalization. When files are created
on macOS, the filesystem uses NFD (decomposed) normalization. When the same
files are accessed on Windows or Linux (or when Google creates them), they
may use NFC (composed) normalization.

Example:
- NFC (composed):   "Café.jpg"     -> C a f e U+00E9 . j p g  (é as single char)
- NFD (decomposed): "Café.jpg"     -> C a f e U+0065 U+0301 . j p g  (e + combining accent)

These look identical but are different byte sequences, causing dictionary
lookups to fail.

PROBLEMS
--------

1. Files with accented characters (é, ñ, ü, etc.) may not match on macOS
2. Files with other diacritics (ö, å, etc.) may fail
3. Files with Asian characters may have normalization issues
4. The file_index dictionary uses unnormalized keys, so lookups can fail

Example failure scenario:
```
# Google exports JSON with NFC-normalized title: "Café.jpg"
# macOS filesystem stores file as NFD: "Café.jpg" (different bytes!)
# Lookup fails because keys don't match
```

AFFECTED CODE PATHS
-------------------

1. scanner.py:116-119 - FileInfo creation uses raw filename
2. scanner.py:145 - Index key uses unnormalized (album_name, filename)
3. matcher.py:139-140 - Lookup uses unnormalized key
4. utils.py - get_album_name() returns unnormalized album name

PROPOSED SOLUTION
-----------------

A. Normalize All Filenames to NFC
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

NFC is the canonical normalization form and what most systems use. We should
normalize all filenames to NFC when:
1. Building the file index
2. Parsing JSON titles
3. Looking up matches

```python
# pef/core/utils.py

import unicodedata

def normalize_filename(filename: str) -> str:
    """Normalize a filename to NFC form for consistent matching.

    macOS uses NFD (decomposed) normalization, while Windows/Linux and
    most cloud services use NFC (composed). This ensures consistent
    matching regardless of source platform.

    Args:
        filename: Original filename (may be NFC or NFD).

    Returns:
        NFC-normalized filename.

    Example:
        >>> normalize_filename("Café.jpg")  # NFD input
        'Café.jpg'  # NFC output (same visual, different bytes)
    """
    return unicodedata.normalize("NFC", filename)


def normalize_path(path: str) -> str:
    """Normalize path components to NFC form.

    Only normalizes the filename and immediate parent directory,
    not the entire path (to preserve exact paths for file operations).

    Args:
        path: File path to normalize.

    Returns:
        Path with normalized filename component.
    """
    directory = os.path.dirname(path)
    filename = os.path.basename(path)
    return os.path.join(directory, normalize_filename(filename))
```

B. Update FileScanner to Normalize
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```python
# pef/core/scanner.py

from pef.core.utils import normalize_filename

class FileScanner:
    def scan(self, on_progress: Optional[ProgressCallback] = None) -> None:
        # ... existing code ...

        for dirpath, dirnames, filenames in _fast_walk(self.path):
            album_name = normalize_filename(os.path.basename(dirpath))

            for filename in filenames:
                filepath = os.path.join(dirpath, filename)

                # Normalize filename for consistent matching
                normalized_filename = normalize_filename(filename)

                if filename.endswith(".json"):
                    self.jsons.append(filepath)
                else:
                    file_info = FileInfo(
                        filename=normalized_filename,  # Store normalized
                        filepath=filepath,              # Keep original for file ops
                        album_name=album_name
                    )
                    self.files.append(file_info)

        # ... rest of method ...

    def _build_index(self) -> None:
        """Build the file index for fast lookups using normalized keys."""
        self.file_index = {}
        for file_info in self.files:
            # Key uses normalized values (already normalized in scan)
            key = (file_info.album_name, file_info.filename)
            if key not in self.file_index:
                self.file_index[key] = []
            self.file_index[key].append(file_info)
```

C. Update FileMatcher to Normalize
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```python
# pef/core/matcher.py

from pef.core.utils import normalize_filename, get_album_name

class FileMatcher:
    def parse_title(self, title: str, json_path: str) -> ParsedTitle:
        """Parse a title into components, handling Google's quirks.

        Normalizes the title to NFC for consistent matching across platforms.
        """
        # Normalize title first
        title = normalize_filename(title)

        name, ext = os.path.splitext(title)

        # ... rest of existing code ...

    def find_match(
        self,
        json_path: str,
        title: str,
        file_index: Optional[FileIndex] = None
    ) -> MatchResult:
        """Find media file(s) matching a JSON metadata file."""
        index = file_index if file_index is not None else self.file_index
        parsed = self.parse_title(title, json_path)

        # Normalize album name for lookup
        album_name = normalize_filename(get_album_name(json_path))

        # ... rest of existing code ...
```

D. Update FileInfo Model
~~~~~~~~~~~~~~~~~~~~~~~~

Add documentation clarifying the normalization behavior:

```python
# pef/core/models.py

@dataclass(slots=True)
class FileInfo:
    """Information about a media file.

    Attributes:
        filename: NFC-normalized filename for matching. Use this for
                  dictionary lookups and comparisons.
        filepath: Original filesystem path. Use this for actual file
                  operations (copy, read, etc.). May contain NFD on macOS.
        album_name: NFC-normalized album (parent directory) name.
        output_path: Destination path after processing.
        json_path: Path to associated JSON metadata file.

    Note:
        The filename and album_name are normalized to NFC form to ensure
        consistent matching across platforms. The filepath preserves the
        original path for file operations.
    """
    filename: str           # NFC-normalized for matching
    filepath: str           # Original path for file operations
    album_name: str         # NFC-normalized for matching
    output_path: Optional[str] = None
    json_path: Optional[str] = None
```

E. Add Normalization Tests
~~~~~~~~~~~~~~~~~~~~~~~~~~

```python
# pef/tests/test_unicode.py

import unicodedata
import pytest
from pef.core.utils import normalize_filename
from pef.core.scanner import FileScanner
from pef.core.matcher import FileMatcher

class TestUnicodeNormalization:
    """Test Unicode normalization handling for cross-platform compatibility."""

    def test_normalize_nfc_passthrough(self):
        """NFC input should pass through unchanged."""
        nfc = "Café.jpg"
        assert normalize_filename(nfc) == nfc

    def test_normalize_nfd_to_nfc(self):
        """NFD input should be converted to NFC."""
        # Create NFD string explicitly
        nfd = unicodedata.normalize("NFD", "Café.jpg")
        nfc = unicodedata.normalize("NFC", "Café.jpg")

        # They look the same but are different bytes
        assert nfd == nfc  # Visual equality
        assert nfd.encode() != nfc.encode()  # Byte difference

        # Normalization should produce NFC
        result = normalize_filename(nfd)
        assert result.encode() == nfc.encode()

    def test_normalize_various_characters(self):
        """Test normalization of various Unicode characters."""
        test_cases = [
            "naïve.jpg",       # i with diaeresis
            "résumé.pdf",      # multiple accents
            "日本語.png",       # Japanese
            "Ängström.tiff",   # Swedish
            "Müller.heic",     # German umlaut
        ]

        for filename in test_cases:
            nfd = unicodedata.normalize("NFD", filename)
            nfc = unicodedata.normalize("NFC", filename)

            # Both should normalize to same result
            assert normalize_filename(nfd) == normalize_filename(nfc)

    def test_matcher_finds_nfd_file_with_nfc_title(self):
        """Matcher should find NFD-named file when JSON has NFC title."""
        # Simulate macOS file (NFD) with Google JSON (NFC)
        nfd_filename = unicodedata.normalize("NFD", "Café.jpg")
        nfc_title = unicodedata.normalize("NFC", "Café.jpg")

        # Create mock file index with NFD filename
        # After normalization, lookup should succeed
        # ... test implementation ...

    def test_scanner_normalizes_filenames(self, tmp_path):
        """Scanner should normalize filenames in index."""
        # Create file with NFD name
        nfd_name = unicodedata.normalize("NFD", "tëst.jpg")
        (tmp_path / nfd_name).touch()

        scanner = FileScanner(str(tmp_path))
        scanner.scan()

        # Index should use NFC key
        nfc_name = unicodedata.normalize("NFC", "tëst.jpg")
        album = tmp_path.name

        assert (album, nfc_name) in scanner.file_index
```

================================================================================
IMPLEMENTATION PLAN
================================================================================

PHASE 1: Unicode Normalization (Low Risk)
-----------------------------------------
Estimated complexity: Low
Files to modify: 4

1. Add normalize_filename() to pef/core/utils.py
2. Update FileScanner.scan() to normalize filenames
3. Update FileMatcher.parse_title() to normalize titles
4. Add test_unicode.py with comprehensive tests

Testing:
- Create test files with NFD names on macOS
- Verify matching works across platforms
- Run full test suite to catch regressions

PHASE 2: ExifTool Installation Improvements (Medium Risk)
---------------------------------------------------------
Estimated complexity: Medium
Files to modify: 2

1. Add platform-specific installation instructions to exiftool.py
2. Add auto_download_exiftool_unix() for Linux/macOS
3. Add auto_install_exiftool_macos() for Homebrew users
4. Update get_exiftool_path() to try all methods
5. Add --check CLI flag for environment validation

Testing:
- Test on clean macOS system (no ExifTool)
- Test on clean Ubuntu system (no ExifTool)
- Test auto-download on systems with/without Perl
- Test Homebrew installation on macOS
- Verify graceful degradation when installation fails

================================================================================
BACKWARDS COMPATIBILITY
================================================================================

Both changes are backwards compatible:

1. Unicode normalization:
   - Existing correctly-matched files will continue to work
   - Files that previously failed to match may now succeed
   - No changes to output format or file structure

2. ExifTool installation:
   - Windows behavior unchanged (existing auto-download works)
   - macOS/Linux gains new auto-install capability
   - Falls back to manual installation if auto-install fails
   - Existing manual installations continue to work

================================================================================
TESTING REQUIREMENTS
================================================================================

1. Unit tests for normalize_filename()
2. Integration tests for cross-platform matching
3. Manual testing on:
   - Windows 10/11
   - macOS (Intel and Apple Silicon)
   - Ubuntu 22.04 LTS
   - Ubuntu 24.04 LTS
4. Test with real Google Takeout exports containing:
   - Accented filenames (French, German, Spanish)
   - Asian character filenames
   - Files created on different platforms

================================================================================
RISKS AND MITIGATIONS
================================================================================

Risk: Normalization changes existing matching behavior
Mitigation: NFC is standard; this should only fix broken matches

Risk: Auto-install requires network access
Mitigation: Graceful fallback to manual install instructions

Risk: Homebrew command may require sudo or fail
Mitigation: Catch errors and provide manual instructions

Risk: Downloaded ExifTool may have security issues
Mitigation: Download only from official exiftool.org domain

================================================================================
REFERENCES
================================================================================

- Unicode Normalization: https://unicode.org/reports/tr15/
- Python unicodedata: https://docs.python.org/3/library/unicodedata.html
- macOS Filename Encoding: https://developer.apple.com/library/archive/qa/qa1173/
- ExifTool Installation: https://exiftool.org/install.html
- Homebrew: https://brew.sh/

================================================================================
